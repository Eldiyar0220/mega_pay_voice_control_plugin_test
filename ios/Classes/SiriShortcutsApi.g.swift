// Autogenerated from Pigeon (v4.2.14), do not edit directly.
// See also: https://pub.dev/packages/pigeon

import Foundation
#if os(iOS)
import Flutter
#elseif os(macOS)
import FlutterMacOS
#else
#error("Unsupported platform.")
#endif


/// Generated class from Pigeon.

enum CreateShortcutStatus: Int {
  case cancelled = 0
  case added = 1
  case deleted = 2
  case updated = 3
}

/// Generated class from Pigeon that represents data sent in messages.
struct CreateShortcutResult {
  var status: CreateShortcutStatus
  var phrase: String? = nil
  var errorMessage: String? = nil

  static func fromList(_ list: [Any?]) -> CreateShortcutResult? {
    let status = CreateShortcutStatus(rawValue: list[0] as! Int)!
    let phrase = list[1] as? String 
    let errorMessage = list[2] as? String 

    return CreateShortcutResult(
      status: status,
      phrase: phrase,
      errorMessage: errorMessage
    )
  }
  func toList() -> [Any?] {
    return [
      status.rawValue,
      phrase,
      errorMessage,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct ShortcutDetail {
  var activityType: String
  var userInfo: [String?: Any?]

  static func fromList(_ list: [Any?]) -> ShortcutDetail? {
    let activityType = list[0] as! String
    let userInfo = list[1] as! [String?: Any?]

    return ShortcutDetail(
      activityType: activityType,
      userInfo: userInfo
    )
  }
  func toList() -> [Any?] {
    return [
      activityType,
      userInfo,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct ShortcutOptions {
  /// The activity type associated with the shortcut.
  var activityType: String
  /// The user-visible title for the shortcut.
  var title: String
  /// A human-understandable string that can be used to suggest a voice shortcut phrase to the user.
  var suggestedInvocationPhrase: String? = nil
  /// A map containing app-specific state information needed to continue an activity on another device.
  var userInfo: [String?: Any?]? = nil
  /// The eligibility for the shortcut.
  var eligibility: ShortcutEligibility? = nil
  /// A description for the shortcut.
  var description: String? = nil
  /// The keys from the userInfo property which represent the minimal information
  /// about the shortcut that should be stored for later restoration.
  ///
  /// A null value means all keys are required.
  var requiredUserInfoKeys: [String?]? = nil
  /// Indicates that the state of the activity needs to be updated.
  var needsSave: Bool? = nil
  /// When no suitable application is installed on a resuming device and the webpageURL is set,
  /// the shortcut will instead be continued in a web browser by loading this resource.
  var webpageURL: String? = nil
  /// The URL of the webpage that referred (linked to) [webpageURL].
  var referrerURL: String? = nil
  /// If non-null, then an absolute date after which
  /// the shortcut is no longer eligible to be indexed or handed off.
  var expirationDate: Int32? = nil
  /// A set of keywords, representing words or phrases in the current user's language
  /// that might help the user to find the shortcut in the application history.
  var keywords: [String?]? = nil
  /// A value used to identify the shortcut.
  var persistentIdentifier: String? = nil
  /// The content type of the shortcut's attribute set.
  var contentType: String? = nil

  static func fromList(_ list: [Any?]) -> ShortcutOptions? {
    let activityType = list[0] as! String
    let title = list[1] as! String
    let suggestedInvocationPhrase = list[2] as? String 
    let userInfo = list[3] as? [String?: Any?] 
    var eligibility: ShortcutEligibility? = nil
    if let eligibilityList = list[4] as? [Any?] {
      eligibility = ShortcutEligibility.fromList(eligibilityList)
    }
    let description = list[5] as? String 
    let requiredUserInfoKeys = list[6] as? [String?] 
    let needsSave = list[7] as? Bool 
    let webpageURL = list[8] as? String 
    let referrerURL = list[9] as? String 
    let expirationDate = list[10] as? Int32 
    let keywords = list[11] as? [String?] 
    let persistentIdentifier = list[12] as? String 
    let contentType = list[13] as? String 

    return ShortcutOptions(
      activityType: activityType,
      title: title,
      suggestedInvocationPhrase: suggestedInvocationPhrase,
      userInfo: userInfo,
      eligibility: eligibility,
      description: description,
      requiredUserInfoKeys: requiredUserInfoKeys,
      needsSave: needsSave,
      webpageURL: webpageURL,
      referrerURL: referrerURL,
      expirationDate: expirationDate,
      keywords: keywords,
      persistentIdentifier: persistentIdentifier,
      contentType: contentType
    )
  }
  func toList() -> [Any?] {
    return [
      activityType,
      title,
      suggestedInvocationPhrase,
      userInfo,
      eligibility?.toList(),
      description,
      requiredUserInfoKeys,
      needsSave,
      webpageURL,
      referrerURL,
      expirationDate,
      keywords,
      persistentIdentifier,
      contentType,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct ShortcutEligibility {
  /// Set to true if the shortcut should be indexed by App History.
  var search: Bool
  /// Set to true if Siri should suggest the shortcut to users.
  var prediction: Bool
  /// Set to true if the shortcut should be eligible to be handed off to another device.
  var handOff: Bool
  /// Set to true if the shortcut should be eligible for indexing for any user of this application,
  /// on any device, or false if the activity contains private or sensitive information or
  /// which would not be useful to other users if indexed.
  ///
  /// The activity must also have [ShortcutOptions.requiredUserActivityKeys]
  /// or a [ShortcutOptions.webpageURL].
  var publicIndexing: Bool

  static func fromList(_ list: [Any?]) -> ShortcutEligibility? {
    let search = list[0] as! Bool
    let prediction = list[1] as! Bool
    let handOff = list[2] as! Bool
    let publicIndexing = list[3] as! Bool

    return ShortcutEligibility(
      search: search,
      prediction: prediction,
      handOff: handOff,
      publicIndexing: publicIndexing
    )
  }
  func toList() -> [Any?] {
    return [
      search,
      prediction,
      handOff,
      publicIndexing,
    ]
  }
}

private class SiriShortcutsApiCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
      case 128:
        return CreateShortcutResult.fromList(self.readValue() as! [Any])      
      case 129:
        return ShortcutEligibility.fromList(self.readValue() as! [Any])      
      case 130:
        return ShortcutOptions.fromList(self.readValue() as! [Any])      
      default:
        return super.readValue(ofType: type)
      
    }
  }
}
private class SiriShortcutsApiCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? CreateShortcutResult {
      super.writeByte(128)
      super.writeValue(value.toList())
    } else if let value = value as? ShortcutEligibility {
      super.writeByte(129)
      super.writeValue(value.toList())
    } else if let value = value as? ShortcutOptions {
      super.writeByte(130)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class SiriShortcutsApiCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return SiriShortcutsApiCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return SiriShortcutsApiCodecWriter(data: data)
  }
}

class SiriShortcutsApiCodec: FlutterStandardMessageCodec {
  static let shared = SiriShortcutsApiCodec(readerWriter: SiriShortcutsApiCodecReaderWriter())
}

/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol SiriShortcutsApi {
  func createShortcut(options: ShortcutOptions, completion: @escaping (CreateShortcutResult) -> Void)
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class SiriShortcutsApiSetup {
  /// The codec used by SiriShortcutsApi.
  static var codec: FlutterStandardMessageCodec { SiriShortcutsApiCodec.shared }
  /// Sets up an instance of `SiriShortcutsApi` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: SiriShortcutsApi?) {
    let createShortcutChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.SiriShortcutsApi.createShortcut", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      createShortcutChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let optionsArg = args[0] as! ShortcutOptions
        api.createShortcut(options: optionsArg) { result in
          reply(wrapResult(result))
        }
      }
    } else {
      createShortcutChannel.setMessageHandler(nil)
    }
  }
}
private class SiriShortcutsFlutterApiCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
      case 128:
        return ShortcutDetail.fromList(self.readValue() as! [Any])      
      default:
        return super.readValue(ofType: type)
      
    }
  }
}
private class SiriShortcutsFlutterApiCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? ShortcutDetail {
      super.writeByte(128)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class SiriShortcutsFlutterApiCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return SiriShortcutsFlutterApiCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return SiriShortcutsFlutterApiCodecWriter(data: data)
  }
}

class SiriShortcutsFlutterApiCodec: FlutterStandardMessageCodec {
  static let shared = SiriShortcutsFlutterApiCodec(readerWriter: SiriShortcutsFlutterApiCodecReaderWriter())
}

/// Generated class from Pigeon that represents Flutter messages that can be called from Swift.
class SiriShortcutsFlutterApi {
  private let binaryMessenger: FlutterBinaryMessenger
  init(binaryMessenger: FlutterBinaryMessenger){
    self.binaryMessenger = binaryMessenger
  }
  var codec: FlutterStandardMessageCodec {
    return SiriShortcutsFlutterApiCodec.shared
  }
  func onShortcutTriggered(detail detailArg: ShortcutDetail, completion: @escaping () -> Void) {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.SiriShortcutsFlutterApi.onShortcutTriggered", binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([detailArg]) { _ in
      completion()
    }
  }
}

private func wrapResult(_ result: Any?) -> [Any?] {
  return [result]
}

private func wrapError(_ error: FlutterError) -> [Any?] {
  return [
    error.code,
    error.message,
    error.details
  ]
}
